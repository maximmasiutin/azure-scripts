#!/bin/bash
# azure-swap.bash - Robust Azure swap configuration script
# Copyright 2025 by Maxim Masiutin. All rights reserved.
#
# This script creates a robust, idempotent swap configuration,
# systemd service, and supporting script. It configures swap using 90% of a
# partition labeled "Temporary Storage", with fallback to /mnt. It sets swappiness
# and updates the initramfs RESUME variable for hibernation.
#
# SECURITY IMPROVEMENTS:
# - Added input validation and sanitization
# - Improved error handling with proper exit codes
# - Added privilege escalation checks
# - Enhanced logging with proper error messages
# - Added file permission validation
# - Implemented safer file operations

set -euo pipefail

# ==== SECURITY AND ERROR HANDLING ====
readonly SCRIPT_NAME="${0##*/}"
readonly SCRIPT_VERSION="2.0.0"

# Logging functions
log_info() { echo "[INFO] $(date '+%Y-%m-%d %H:%M:%S') $*" >&2; }
log_warn() { echo "[WARN] $(date '+%Y-%m-%d %H:%M:%S') $*" >&2; }
log_error() { echo "[ERROR] $(date '+%Y-%m-%d %H:%M:%S') $*" >&2; }
log_fatal() { echo "[FATAL] $(date '+%Y-%m-%d %H:%M:%S') $*" >&2; exit 1; }

# Check if running as root
check_privileges() {
    if [[ $EUID -ne 0 ]]; then
        log_fatal "This script must be run as root (use sudo)"
    fi
}

# Validate system requirements
validate_system() {
    local required_commands=("systemctl" "blkid" "mount" "dd" "mkswap" "swapon")
    local missing_commands=()
    
    for cmd in "${required_commands[@]}"; do
        if ! command -v "$cmd" &>/dev/null; then
            missing_commands+=("$cmd")
        fi
    done
    
    if [[ ${#missing_commands[@]} -gt 0 ]]; then
        log_fatal "Missing required commands: ${missing_commands[*]}"
    fi
    
    # Check if systemd is running
    if ! systemctl is-system-running &>/dev/null && ! systemctl is-system-running --quiet 2>/dev/null; then
        log_warn "systemd may not be fully operational"
    fi
}

# Sanitize path inputs
sanitize_path() {
    local path="$1"
    # Remove any dangerous characters and normalize
    path="${path//[;<>|&\$`]/_}"
    echo "$path"
}

# Validate file permissions
validate_permissions() {
    local file="$1"
    local expected_perms="$2"
    
    if [[ -f "$file" ]]; then
        local actual_perms
        actual_perms=$(stat -c '%a' "$file" 2>/dev/null || echo "000")
        if [[ "$actual_perms" != "$expected_perms" ]]; then
            log_warn "File $file has permissions $actual_perms, expected $expected_perms"
            chmod "$expected_perms" "$file" || log_error "Failed to set permissions on $file"
        fi
    fi
}

# ==== CONFIGURATION VARIABLES ====
readonly UNIT_NAME="robust-swap-setup.service"
readonly UNIT_FILE="/etc/systemd/system/$UNIT_NAME"
readonly SWAP_SCRIPT="/usr/local/bin/configure-swap.sh"
readonly SWAP_LABEL="Temporary Storage"
readonly SWAP_MOUNT="/mnt/temporary_storage"
readonly FALLBACK_SWAPFILE="/mnt/swapfile"
readonly SWAPPINESS="10"
readonly RESUME_CONF="/etc/initramfs-tools/conf.d/resume"
readonly FSTAB="/etc/fstab"
readonly SYSCTL_CONF="/etc/sysctl.conf"
readonly SWAP_FILE_MODE="600"
readonly SERVICE_PERM="644"
readonly SCRIPT_PERM="755"

# Validate swappiness value
if ! [[ "$SWAPPINESS" =~ ^[0-9]+$ ]] || [[ "$SWAPPINESS" -lt 0 ]] || [[ "$SWAPPINESS" -gt 100 ]]; then
    log_fatal "Invalid swappiness value: $SWAPPINESS (must be 0-100)"
fi

# ==== MAIN SCRIPT EXECUTION ====
main() {
    log_info "Starting $SCRIPT_NAME v$SCRIPT_VERSION"
    
    check_privileges
    validate_system
    
    # Create swap configuration script
    create_swap_script
    
    # Create systemd service unit
    create_systemd_unit
    
    # Enable and start the service
    setup_service
    
    log_info "Setup complete. Service '$UNIT_NAME' installed and enabled."
}

# ==== STEP 1: Generate Swap Configuration Script ====
create_swap_script() {
    log_info "Creating swap configuration script at $SWAP_SCRIPT"
    
    # Ensure directory exists with proper permissions
    local script_dir
    script_dir=$(dirname "$SWAP_SCRIPT")
    [[ -d "$script_dir" ]] || mkdir -p "$script_dir"
    
    # Create the script with proper error handling
    cat > "$SWAP_SCRIPT" <<'SWAP_SCRIPT_EOF'
#!/bin/bash
# configure-swap.sh - Azure swap configuration helper
# Auto-generated by azure-swap.bash
# DO NOT EDIT MANUALLY

set -euo pipefail

# Configuration constants
readonly TMP_LABEL="Temporary Storage"
readonly SWAP_MOUNT="/mnt/temporary_storage"
readonly FALLBACK_SWAPFILE="/mnt/swapfile"
readonly SWAPPINESS="10"
readonly RESUME_CONF="/etc/initramfs-tools/conf.d/resume"
readonly FSTAB="/etc/fstab"
readonly SYSCTL_CONF="/etc/sysctl.conf"
readonly SWAP_FILE_MODE="600"

# Logging functions
log() { echo "[swap-setup] $(date '+%Y-%m-%d %H:%M:%S') $*" >&2; }
fail() { log "ERROR: $*"; exit 1; }

# Safe directory creation
try_mkdir() { 
    [[ -d "$1" ]] || {
        mkdir -p "$1" || fail "Failed to create directory: $1"
    }
}

# Validate device path to prevent injection
validate_device() {
    local device="$1"
    if [[ ! "$device" =~ ^/dev/[a-zA-Z0-9_-]+$ ]]; then
        fail "Invalid device path: $device"
    fi
    if [[ ! -b "$device" ]]; then
        fail "Device does not exist or is not a block device: $device"
    fi
}

# Safely get device size
get_device_size() {
    local device="$1"
    validate_device "$device"
    
    local size_bytes
    if ! size_bytes=$(blockdev --getsize64 "$device" 2>/dev/null); then
        # Try alternative method for symlinks
        local real_device
        real_device=$(readlink -f "$device" 2>/dev/null || echo "$device")
        validate_device "$real_device"
        size_bytes=$(blockdev --getsize64 "$real_device" 2>/dev/null) || fail "Cannot get size of $device"
    fi
    
    if [[ ! "$size_bytes" =~ ^[0-9]+$ ]] || [[ "$size_bytes" -eq 0 ]]; then
        fail "Invalid device size: $size_bytes"
    fi
    
    echo "$size_bytes"
}

# Safely check and create swap file
create_swap_file() {
    local swapfile="$1"
    local size_bytes="$2"
    local size_mb=$((size_bytes / 1048576))
    
    # Validate size
    if [[ "$size_mb" -lt 1 ]] || [[ "$size_mb" -gt 1048576 ]]; then  # Max 1TB
        fail "Invalid swap size: ${size_mb}MB"
    fi
    
    # Check available space
    local dir
    dir=$(dirname "$swapfile")
    local available_kb
    available_kb=$(df --output=avail "$dir" | awk 'NR==2 {print $1}')
    local required_kb=$((size_bytes / 1024))
    
    if [[ "$available_kb" -lt "$required_kb" ]]; then
        fail "Insufficient space: need ${required_kb}KB, have ${available_kb}KB"
    fi
    
    log "Creating swap file $swapfile (${size_mb}MB)"
    
    # Remove existing file if present
    [[ -f "$swapfile" ]] && rm -f "$swapfile"
    
    # Create swap file with proper error handling
    if ! dd if=/dev/zero of="$swapfile" bs=1M count="$size_mb" status=progress 2>/dev/null; then
        rm -f "$swapfile"
        fail "Failed to create swap file"
    fi
    
    # Set proper permissions
    chmod "$SWAP_FILE_MODE" "$swapfile" || fail "Failed to set permissions on $swapfile"
    
    # Initialize swap
    if ! mkswap -L systemswap "$swapfile" >/dev/null; then
        rm -f "$swapfile"
        fail "Failed to initialize swap file"
    fi
}

# Safely enable swap
enable_swap() {
    local swapfile="$1"
    
    if ! swapon --show=NAME | grep -qw "$swapfile"; then
        log "Enabling swap file $swapfile"
        swapon "$swapfile" || fail "Failed to enable swap file"
    else
        log "Swap file $swapfile already enabled"
    fi
}

# Safely update fstab
update_fstab() {
    local swapfile="$1"
    local fstab_line="$swapfile none swap sw 0 0"
    
    # Create backup
    cp "$FSTAB" "${FSTAB}.backup.$(date +%s)" || log "Warning: Failed to backup fstab"
    
    if ! grep -qFx "$fstab_line" "$FSTAB"; then
        log "Adding swap file to $FSTAB"
        echo "$fstab_line" >> "$FSTAB" || fail "Failed to update fstab"
    else
        log "Swap file already in fstab"
    fi
}

# Configure resume for hibernation
configure_resume() {
    local swapfile="$1"
    local swap_uuid
    
    # Get UUID safely
    if ! swap_uuid=$(blkid -s UUID -o value "$swapfile" 2>/dev/null); then
        log "Warning: Could not get UUID for swap file, skipping resume configuration"
        return 0
    fi
    
    if [[ -n "$swap_uuid" ]]; then
        log "Configuring RESUME (UUID=$swap_uuid)"
        local resume_dir
        resume_dir=$(dirname "$RESUME_CONF")
        [[ -d "$resume_dir" ]] || mkdir -p "$resume_dir"
        echo "RESUME=UUID=$swap_uuid" > "$RESUME_CONF" || log "Warning: Failed to configure resume"
    fi
}

# Set system swappiness
set_swappiness() {
    log "Configuring swappiness to $SWAPPINESS"
    
    # Apply current setting
    sysctl -w "vm.swappiness=$SWAPPINESS" >/dev/null || fail "Failed to set swappiness"
    
    # Create backup of sysctl.conf
    [[ -f "$SYSCTL_CONF" ]] && cp "$SYSCTL_CONF" "${SYSCTL_CONF}.backup.$(date +%s)"
    
    # Update persistent setting
    if grep -q '^vm.swappiness' "$SYSCTL_CONF" 2>/dev/null; then
        sed -i "s/^vm\.swappiness.*/vm.swappiness = $SWAPPINESS/" "$SYSCTL_CONF"
    else
        echo "vm.swappiness = $SWAPPINESS" >> "$SYSCTL_CONF"
    fi
}

# Update initramfs safely
update_initramfs() {
    if command -v update-initramfs &>/dev/null; then
        log "Updating initramfs (all kernels)"
        if ! update-initramfs -u -k all; then
            log "Warning: Failed to update initramfs with update-initramfs"
        fi
    elif command -v dracut &>/dev/null; then
        log "Updating initramfs (dracut, all kernels)"
        for kver in /lib/modules/*; do
            if [[ -d "$kver" ]]; then
                local kernel_version
                kernel_version=$(basename "$kver")
                if ! dracut -f --kver "$kernel_version"; then
                    log "Warning: Failed to update initramfs for kernel $kernel_version"
                fi
            fi
        done
    else
        log "Warning: No recognized initramfs builder found"
    fi
}

# Main function
main() {
    log "Starting Azure swap configuration"
    
    # Check if running as root
    if [[ $EUID -ne 0 ]]; then
        fail "This script must be run as root"
    fi
    
    # Detect device by label
    local device
    device=$(blkid -L "$TMP_LABEL" 2>/dev/null || true)
    
    if [[ -n "$device" ]]; then
        log "Found device labeled '$TMP_LABEL': $device"
        
        # Create mount point
        try_mkdir "$SWAP_MOUNT"
        
        # Mount partition if needed
        if ! mountpoint -q "$SWAP_MOUNT"; then
            log "Mounting $device to $SWAP_MOUNT"
            mount "$device" "$SWAP_MOUNT" || fail "Failed to mount $device"
        fi
        
        # Get device size and calculate swap size
        local size_bytes
        size_bytes=$(get_device_size "$device")
        local swap_size_bytes=$((size_bytes * 90 / 100))
        
        # Determine swap file path
        local swapfile="$SWAP_MOUNT/system.swap"
        
        # Check if swap file needs recreation
        local recreate_swapfile=0
        if [[ -f "$swapfile" ]]; then
            local actual_size
            actual_size=$(stat -c '%s' "$swapfile" 2>/dev/null || echo "0")
            local min_size=$((swap_size_bytes * 95 / 100))
            local max_size=$((swap_size_bytes * 105 / 100))
            
            if [[ "$actual_size" -lt "$min_size" ]] || [[ "$actual_size" -gt "$max_size" ]]; then
                log "Swap file size mismatch; recreating"
                recreate_swapfile=1
            fi
        else
            recreate_swapfile=1
        fi
        
        # Create swap file if needed
        if [[ "$recreate_swapfile" -eq 1 ]]; then
            create_swap_file "$swapfile" "$swap_size_bytes"
        fi
        
        # Enable swap
        enable_swap "$swapfile"
        
        # Update fstab
        update_fstab "$swapfile"
        
        # Configure resume
        configure_resume "$swapfile"
        
    else
        log "No '$TMP_LABEL' partition found; using fallback swap file"
        
        # Ensure /mnt exists
        try_mkdir "$(dirname "$FALLBACK_SWAPFILE")"
        
        # Calculate fallback swap size
        local free_mnt_kb
        free_mnt_kb=$(df --output=avail /mnt | awk 'NR==2 {print $1}')
        local fallback_size_mb=2048  # 2GB minimum
        
        if [[ -n "$free_mnt_kb" ]] && [[ "$free_mnt_kb" -gt 0 ]]; then
            local calculated_mb=$((free_mnt_kb * 9 / 10 / 1024))
            if [[ "$calculated_mb" -gt "$fallback_size_mb" ]]; then
                fallback_size_mb="$calculated_mb"
            fi
        fi
        
        # Check if fallback swap file needs recreation
        local recreate_swapfile=0
        if [[ -f "$FALLBACK_SWAPFILE" ]]; then
            local actual_size
            actual_size=$(stat -c '%s' "$FALLBACK_SWAPFILE" 2>/dev/null || echo "0")
            local target_size=$((fallback_size_mb * 1048576))
            local min_size=$((target_size * 95 / 100))
            local max_size=$((target_size * 105 / 100))
            
            if [[ "$actual_size" -lt "$min_size" ]] || [[ "$actual_size" -gt "$max_size" ]]; then
                log "Fallback swap file size mismatch; recreating"
                recreate_swapfile=1
            fi
        else
            recreate_swapfile=1
        fi
        
        # Create fallback swap file if needed
        if [[ "$recreate_swapfile" -eq 1 ]]; then
            create_swap_file "$FALLBACK_SWAPFILE" $((fallback_size_mb * 1048576))
        fi
        
        # Enable swap
        enable_swap "$FALLBACK_SWAPFILE"
        
        # Update fstab
        update_fstab "$FALLBACK_SWAPFILE"
        
        # Configure resume
        configure_resume "$FALLBACK_SWAPFILE"
    fi
    
    # Set swappiness
    set_swappiness
    
    # Update initramfs
    update_initramfs
    
    log "Azure swap configuration completed successfully"
}

# Execute main function
main "$@"
SWAP_SCRIPT_EOF

    # Set proper permissions
    chmod "$SCRIPT_PERM" "$SWAP_SCRIPT" || log_fatal "Failed to set permissions on $SWAP_SCRIPT"
    validate_permissions "$SWAP_SCRIPT" "$SCRIPT_PERM"
    
    log_info "Swap configuration script created successfully"
}

# ==== STEP 2: Generate systemd unit file ====
create_systemd_unit() {
    log_info "Creating systemd unit file at $UNIT_FILE"
    
    # Sanitize paths for systemd unit
    local safe_script_path
    safe_script_path=$(sanitize_path "$SWAP_SCRIPT")
    
    cat > "$UNIT_FILE" <<EOF
[Unit]
Description=Robust Azure swap configuration (90%% of Temporary Storage or fallback)
Documentation=man:swapon(8) man:systemd.swap(5)
After=local-fs.target
Before=swap.target
DefaultDependencies=yes
ConditionPathExists=$safe_script_path

[Service]
Type=oneshot
ExecStart=$safe_script_path
RemainAfterExit=yes
TimeoutStartSec=300
StandardOutput=journal
StandardError=journal
PrivateTmp=true
ProtectSystem=strict
ReadWritePaths=/etc /mnt /var/log
NoNewPrivileges=false
CapabilityBoundingSet=CAP_SYS_ADMIN CAP_DAC_OVERRIDE CAP_FOWNER

[Install]
WantedBy=multi-user.target
EOF

    # Set proper permissions
    chmod "$SERVICE_PERM" "$UNIT_FILE" || log_fatal "Failed to set permissions on $UNIT_FILE"
    validate_permissions "$UNIT_FILE" "$SERVICE_PERM"
    
    log_info "Systemd unit file created successfully"
}

# ==== STEP 3: Setup and enable the service ====
setup_service() {
    log_info "Setting up systemd service"
    
    # Reload systemd configuration
    if ! systemctl daemon-reload; then
        log_fatal "Failed to reload systemd daemon"
    fi
    
    # Enable the service
    if ! systemctl enable "$UNIT_NAME"; then
        log_fatal "Failed to enable service $UNIT_NAME"
    fi
    
    # Start the service
    if ! systemctl start "$UNIT_NAME"; then
        log_error "Failed to start service $UNIT_NAME"
        # Show service status for debugging
        systemctl status "$UNIT_NAME" --no-pager || true
        exit 1
    fi
    
    # Verify service is active
    if systemctl is-active --quiet "$UNIT_NAME"; then
        log_info "Service $UNIT_NAME is active and running"
    else
        log_warn "Service $UNIT_NAME may not be running properly"
        systemctl status "$UNIT_NAME" --no-pager || true
    fi
}

# Show usage information
show_usage() {
    cat << EOF
Usage: $SCRIPT_NAME [OPTIONS]

This script creates a robust Azure swap configuration that:
- Uses 90% of "Temporary Storage" partition for swap
- Falls back to /mnt/swapfile if no temporary storage found
- Creates systemd service for automatic setup on boot
- Configures hibernation resume support
- Sets optimal swappiness value

OPTIONS:
    -h, --help      Show this help message
    -v, --version   Show version information

EXAMPLES:
    sudo $SCRIPT_NAME                    # Standard installation
    $SCRIPT_NAME --help                  # Show help

SECURITY NOTES:
- Must be run as root (use sudo)
- Creates files with restricted permissions
- Validates all inputs and paths
- Includes comprehensive error handling

For more information, see the Azure documentation on temporary storage.
EOF
}

# Parse command line arguments
parse_args() {
    while [[ $# -gt 0 ]]; do
        case $1 in
            -h|--help)
                show_usage
                exit 0
                ;;
            -v|--version)
                echo "$SCRIPT_NAME version $SCRIPT_VERSION"
                exit 0
                ;;
            *)
                log_error "Unknown option: $1"
                show_usage
                exit 1
                ;;
        esac
        shift
    done
}

# Script entry point
parse_args "$@"
main

log_info "$SCRIPT_NAME completed successfully"
